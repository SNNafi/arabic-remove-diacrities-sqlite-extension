// Originally by Unknown Author, Public Domain
// https://github.com/Zensey/sqlite3_unicode

// Modified by Shahriar Nasim Nafi, MIT License
// https://github.com/snnafi

/*
 * Implements arabic string comparison for Unicode strings.
 * Provides the following Unicode features:
 *
 *   - remove_diacritic() function to normalize arabic strings by removing diacritics.
 *
 *
 * Compile the project with the SQLITE_ENABLE_UNICODE preprocessor definition
 * in order to enable the code below.
 */

#pragma warning(disable : 4305 13 90)

/*
** Un|Comment to provide additional unicode support to SQLite3 or adjust size for unused features
*/
#define SQLITE3_UNICODE_FOLD   // ~ 10KB increase
#define SQLITE3_UNICODE_LOWER  // ~ 10KB increase
#define SQLITE3_UNICODE_UPPER  // ~ 10KB increase
// #define SQLITE3_UNICODE_TITLE  // ~ 10KB increase
#define SQLITE3_UNICODE_UNACC  // ~ 30KB increase \
                               // _______________ \
                               // ~ 70KB increase

/*
** SQLITE3_UNICODE_COLLATE will register and use the custom nocase collation instead of the standard
** one, which supports case folding and unaccenting.
*/
#define SQLITE3_UNICODE_COLLATE  // requires SQLITE3_UNICODE_FOLD to be defined as well.

/*
** SQLITE3_UNICODE_UNACC_AUTOMATIC will automatically try to unaccent any characters that
** are over the 0x80 character in the LIKE comparison operation and in the NOCASE collation
*sequence.
*/
#define SQLITE3_UNICODE_UNACC_AUTOMATIC  // requires SQLITE3_UNICODE_UNACC to be defined as well.

#define SQLITE3_UNICODE_VERSION_MAJOR 5
#define SQLITE3_UNICODE_VERSION_MINOR 1
#define SQLITE3_UNICODE_VERSION_MICRO 0
#define SQLITE3_UNICODE_VERSION_BUILD 12

#define __SQLITE3_UNICODE_VERSION_STRING(a, b, c, d) #a "." #b "." #c "." #d
#define _SQLITE3_UNICODE_VERSION_STRING(a, b, c, d) __SQLITE3_UNICODE_VERSION_STRING(a, b, c, d)
#define SQLITE3_UNICODE_VERSION_STRING                                                            \
    _SQLITE3_UNICODE_VERSION_STRING(SQLITE3_UNICODE_VERSION_MAJOR, SQLITE3_UNICODE_VERSION_MINOR, \
                                    SQLITE3_UNICODE_VERSION_MICRO, SQLITE3_UNICODE_VERSION_BUILD)

/* Generated by builder. Do not modify. End unicode_version_defines */

#if !defined(SQLITE_CORE) || defined(SQLITE_ENABLE_UNICODE)

#ifndef SQLITE_CORE

#include "sqlite3ext.h"

SQLITE_EXTENSION_INIT1
#else
#include "sqlite3.h"
#endif

#include <assert.h>
#include <string.h>

#ifndef _SQLITE3_UNICODE_H
#define _SQLITE3_UNICODE_H

#ifdef __cplusplus
extern "C" {
#endif

/*
** Add the ability to override 'extern'
*/
/*
** <sqlite3_unicode>
** The define of SQLITE_EXPORT is necessary to add the ability of exporting
** functions for both Microsoft Windows and Linux systems without the need
** of a .def file containing the names of the functions being exported.
*/
#ifndef SQLITE_EXPORT
#if ((defined(_WIN32) || defined(WIN32) || defined(__CYGWIN__) || defined(__MINGW32__) || \
      defined(__BORLANDC__)) && \
     (!defined(SQLITE_CORE)))
#define SQLITE_EXPORT __declspec(dllexport)
#else
#define SQLITE_EXPORT SQLITE_EXTERN
#endif
#endif

#ifndef SQLITE_PRIVATE
#define SQLITE_PRIVATE static
#endif
#ifndef SQLITE_API
#define SQLITE_API
#endif

/*
** Integers of known sizes.  These typedefs might change for architectures
** where the sizes very.  Preprocessor macros are available so that the
** types can be conveniently redefined at compile-type.  Like this:
**
**         cc '-DUINTPTR_TYPE=long long int' ...
*/
#ifndef UINT32_TYPE
#ifdef HAVE_UINT32_T
#define UINT32_TYPE uint32_t
#else
#define UINT32_TYPE unsigned int
#endif
#endif
#ifndef UINT16_TYPE
#ifdef HAVE_UINT16_T
#define UINT16_TYPE uint16_t
#else
#define UINT16_TYPE unsigned short int
#endif
#endif
#ifndef INT16_TYPE
#ifdef HAVE_INT16_T
#define INT16_TYPE int16_t
#else
#define INT16_TYPE short int
#endif
#endif
#ifndef UINT8_TYPE
#ifdef HAVE_UINT8_T
#define UINT8_TYPE uint8_t
#else
#define UINT8_TYPE unsigned char
#endif
#endif
#ifndef INT8_TYPE
#ifdef HAVE_INT8_T
#define INT8_TYPE int8_t
#else
#define INT8_TYPE signed char
#endif
#endif
#ifndef LONGDOUBLE_TYPE
#define LONGDOUBLE_TYPE long double
#endif
typedef sqlite_int64
i64;  /* 8-byte signed integer */
typedef sqlite_uint64 u64; /* 8-byte unsigned integer */
typedef UINT32_TYPE u32;   /* 4-byte unsigned integer */
typedef UINT16_TYPE u16;   /* 2-byte unsigned integer */
typedef INT16_TYPE i16;    /* 2-byte signed integer */
typedef UINT8_TYPE u8;     /* 1-byte unsigned integer */
typedef INT8_TYPE i8;      /* 1-byte signed integer */

/*
** <sqlite3_unicode>
** These functions are intended for case conversion of single characters
** and return a single character containing the case converted character
** based on the unicode mapping tables.
*/
SQLITE_EXPORT u16
sqlite3_unicode_fold(u16
c);
SQLITE_EXPORT u16
sqlite3_unicode_lower(u16
c);
SQLITE_EXPORT u16
sqlite3_unicode_upper(u16
c);
SQLITE_EXPORT u16
sqlite3_unicode_title(u16
c);

/*
** <sqlite3_unicode>
** This function is intended for decomposing of single characters
** and return a pointer of characters (u16 **)p containing the decomposed
** character or string of characters. (int *)l will contain the length
** of characters contained in (u16 **)p based on the unicode mapping tables.
*/


/*
** Another built-in collating sequence: NOCASE.
**
** This collating sequence is intended to be used for "case independant
** comparison". SQLite's knowledge of upper and lower case equivalents
** extends only to the 26 characters used in the English language.
**
** At the moment there is only a UTF-8 implementation.
*/
/*
** <sqlite3_unicode>
** The built-in collating sequence: NOCASE is extended to accomodate the
** unicode case folding mapping tables to normalize characters to their
** fold equivalents and test them for equality.
**
** Both UTF-8 and UTF-16 implementations are supported.
**
** (void *)encoding takes the following values
**   * SQLITE_UTF8  for UTF-8  encoded string comparison
**   * SQLITE_UFT16 for UTF-16 encoded string comparison
*/
SQLITE_EXPORT int sqlite3_unicode_collate(void *encoding,
                                          int nKey1,
                                          const void *pKey1,
                                          int nKey2,
                                          const void *pKey2);

/*
** <sqlite3_unicode>
** The following function needs to be called at application startup to load the extension.
*/
SQLITE_EXPORT int sqlite3_unicode_load();

/*
** <sqlite3_unicode>
** The following function needs to be called before application exit to unload the extension.
*/
SQLITE_EXPORT void sqlite3_unicode_free();

#ifdef __cplusplus
}
#endif

#endif /* _SQLITE3_UNICODE_H */
/*************************************************************************************************
 *************************************************************************************************
 *************************************************************************************************/

#ifdef SQLITE3_UNICODE_UNACC

static unsigned short unicode_arabic[] = {
        0x0610, 0x0611, 0x0612, 0x0613, 0x0614,

        0x0615, 0x0616, 0x0617, 0x0618, 0x0619, 0x061A, 0x06D6, 0x06D7, 0x06D8, 0x06D9, 0x06DA,
        0x06DB, 0x06DC, 0x06DD, 0x06DE, 0x06DF, 0x06E0, 0x06E1, 0x06E2, 0x06E3, 0x06E4, 0x06E5,
        0x06E6, 0x06E7, 0x06E8, 0x06E9, 0x06EA, 0x06EB, 0x06EC, 0x06ED,

        0x0640,

        0x064B, 0x064C, 0x064D, 0x064E, 0x064F, 0x0650, 0x0651, 0x0652, 0x0653, 0x0654, 0x0655,
        0x0656, 0x0657, 0x0658, 0x0659, 0x065A, 0x065B, 0x065C, 0x065D, 0x065E, 0x065F, 0x0670,
        0x0623, 0x0625, 0x0622, 0x0671, // (i >= 58 && i <= 61) 0x0627
        0x064A, 0x0621, 0x0647, // (i >= 62 && i <= 64) index = i - 62
};

static unsigned short unicode_arabic_replace[] = {
        0x0649, 0x0624, 0x0629
};


SQLITE_PRIVATE int unicode_diacritic(const u16 *zIn) {

    int found = 0;
    for (int i = 0; i < 64; i++) {
        if (unicode_arabic[i] == *(zIn)) {
            found = i;
            break;
        }
    }
    return found;
}

#endif


/*
** Allocate nByte bytes of space using sqlite3_malloc(). If the
** allocation fails, call sqlite3_result_error_nomem() to notify
** the database handle that malloc() has failed.
*/
static void *contextMalloc(sqlite3_context *context, i64 nByte) {
    char *z;
#if 0
    if( nByte>sqlite3_context_db_handle(context)->aLimit[SQLITE_LIMIT_LENGTH] ){
      sqlite3_result_error_toobig(context);
      z = 0;
    }else{
#endif
    z = sqlite3_malloc((int) nByte);
    if (!z && nByte > 0) {
        sqlite3_result_error_nomem(context);
    }
#if 0
    }
#endif
    return z;
}

/*
** <sqlite3_unicode>
** Reallocate nByte bytes of space using sqlite3_realloc(). If the
** allocation fails, call sqlite3_result_error_nomem() to notify
** the database handle that malloc() has failed.
**
** SQlite has not supplied us with a reallocate function so we build our own.
*/
SQLITE_PRIVATE void *contextRealloc(sqlite3_context *context, void *pPrior, i64 nByte) {
    char *z = sqlite3_realloc(pPrior, (int) nByte);
    if (!z && nByte > 0) {
        sqlite3_result_error_nomem(context);
    }
    return z;
}


#ifdef SQLITE3_UNICODE_UNACC
/*
** <sqlite3_unicode>
** Implementation of the REMOVE_DIACRITIC() SQL function.
** This function decomposes each character in the supplied arabic string
** to its components and strips any diacritics present in the arabic string.
**
** This function may result to a longer output arabic string compared
** to the original input string. Memory has been properly reallocated
** to accomodate for the extra memory length required.
*/

SQLITE_PRIVATE void diacriticFunc(sqlite3_context *context, int argc, sqlite3_value **argv) {
    u16 * z1;
    const u16 *z2;
    unsigned short *p;
    int i, o, n;
    if (argc < 1 || SQLITE_NULL == sqlite3_value_type(argv[0]))
        return;
    z2 = (u16 *) sqlite3_value_text16(argv[0]);
    n = sqlite3_value_bytes16(argv[0]);
    /* Verify that the call to _bytes() does not invalidate the _text() pointer */
    assert(z2 == (u16 *) sqlite3_value_text16(argv[0]));
    if (z2) {
        z1 = contextMalloc(context, n + 2);
        if (z1) {
            memcpy(z1, z2, n + 2);
            int i = 0;
            int o = 0;
            while (z2[i]) {
                int index = unicode_diacritic(z2 + i);
                if (index == 0) {
                    z1[o] = z2[i];
                    o++;
                } else if (index >= 58 && index <= 61) {
                    z1[o] = 0x0627;
                    o++;
                } else if (index >= 62 && index <= 64) {
                    z1[o] = unicode_arabic_replace[index - 62];
                    o++;
                }
                i++;
            }
            z1[o] = 0;
            sqlite3_result_text16(context, z1, -1, sqlite3_free);
        }
    }
}

#endif






/*
** <sqlite3_unicode>
** Implementation of the UNICODE_VERSION(*) function.  The result is the version
** of the unicode library that is running.
*/
SQLITE_PRIVATE void versionFunc(sqlite3_context *context, int argc, sqlite3_value **argv) {
    sqlite3_result_text(context, SQLITE3_UNICODE_VERSION_STRING, -1, SQLITE_STATIC);
}

/*
** <sqlite3_unicode>
** Register the UNICODE extension functions with database db.
*/
SQLITE_EXPORT int sqlite3_unicode_init_impl(sqlite3 *db) {
    struct FuncScalar {
        const char *zName; /* Function name */
        int nArg;          /* Number of arguments */
        int enc;           /* Optimal text encoding */
        void *pContext;    /* sqlite3_user_data() context */
        void (*xFunc)(sqlite3_context *, int, sqlite3_value **);
    } scalars[] = {
            {"unicode_version", 0, SQLITE_ANY, 0, versionFunc},

#ifdef SQLITE3_UNICODE_UNACC
            {"remove_diacritic", 1, SQLITE_ANY, 0, diacriticFunc},
#endif
    };

    for (int i = 0; i < (sizeof(scalars) / sizeof(struct FuncScalar)); i++) {
        struct FuncScalar *p = &scalars[i];
        sqlite3_create_function(db, p->zName, p->nArg, p->enc, p->pContext, p->xFunc, 0, 0);
    }

    return SQLITE_OK;
}

/*
** <sqlite3_unicode>
** The following function is the default entry point of an SQlite extension built as a
** dynamically linked library. On calling sqlite3_load_extension() sqlite3 will call
** this function to initialise unicode functionality.
*/
#ifndef SQLITE_CORE

SQLITE_EXPORT int sqlite3_removearabicdiacritic_init(sqlite3 *db,
                                                     char **pzErrMsg,
                                                     const sqlite3_api_routines *pApi) {
    SQLITE_EXTENSION_INIT2(pApi)
    return sqlite3_unicode_init_impl(db);
}

#endif

#endif  //! defined(SQLITE_CORE) || defined(SQLITE_ENABLE_UNICODE)
